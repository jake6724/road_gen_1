extends Node2D
class_name HighwayGenerator

"""
NOTES

- Highways that generate close to another highway should use the same on instead, and then branch off

"""

@export_group("Population Center Detection")
@export var num_population_centers: int = 10
@export var population_center_min_distance: int = 200
@export var population_density: PopulationDensityGenerator

@export_group("Highway Generation")
## Sample range is +/- `degree_range`, with the center being the direct angle to `target_point`
@export var degree_range: float = 5
## How much to adjust when sweeping through `degree_range`
@export var degree_step: float = 1 
## The length of an individual highway segment, which are combined to create the final highway
@export var num_samples: int = 25 

var marker: PackedScene = preload("res://scenes/Marker.tscn")
var highway_sample_marker: PackedScene = preload("res://scenes/HighwaySampleMarker.tscn")
var target_marker: PackedScene = preload("res://scenes/TargetMarker.tscn")

var map_height: int = 1000
var map_width: int = 1000
var noise_values: Array = []
var pc_heap: MinHeap = MinHeap.new()

func _ready():
	var population_centers: Array = find_population_centers()
	connect_population_centers(population_centers)

## Find the top `num_population_centers` peaks of the noise layers generated by `population_density_generator`. 
## Return a normalized, sorted array containing `num_population_center` pairs of (density_value:float, coordinates:Vector2)
func find_population_centers() -> Array:
	# Populate min heap
	for x in range(map_height):
		for y in range(map_width):
			var base_noise_value: float = population_density.base_noise.get_noise_2d(x,y)
			# var detail_noise_value: float = population_density.detail_noise.get_noise_2d(x,y)
			# var combined_noise_value: float = base_noise_value + detail_noise_value
			if pc_heap.data.size() < num_population_centers:
				pc_heap.push([base_noise_value, Vector2(x,y)])

			elif base_noise_value > pc_heap.peek()[0]:
				# Check if current point is too close to other population centers
				var point: Vector2 = Vector2(x, y)
				var count: int = 0
				for pc in pc_heap.data:
					if point.distance_to(pc[1]) > population_center_min_distance:
						count += 1
				# Check if this PC min distance check passed against all existing PCs
				if count == pc_heap.data.size():
					pc_heap.pop()
					pc_heap.push([base_noise_value, Vector2(x,y)])

	# Normalize population center density values, add PC markers
	var min_density = pc_heap.data.min()[0]
	var max_density = pc_heap.data.max()[0]
	var normalization_min: float = .1 # Minimum range for the value normalization [min, 1]
	pc_heap.data.sort()
	for pc in pc_heap.data:
		var value: float = pc[0]
		var normalized_value: float = normalization_min + ((value - min_density) / (max_density - min_density) * (1 - normalization_min)) 
		var point: Vector2 = pc[1]
		add_population_center_marker(point, normalized_value)
	
	return pc_heap.data

func connect_population_centers(population_centers) -> void:
	for pc in population_centers.slice(0, population_centers.size()-1):
		print("From: ", population_centers[-1][1], " To: ", pc[1])
		build_highway(population_centers[-1][1], pc[1])

## Find the highest density path between `start_point` and `target_point`, in segments of `num_samples` size. 
func build_highway(current_point: Vector2, target_point: Vector2):
	# Initialize highway Line2D
	var highway: Line2D = create_new_highway_line2d()
	
	# Sample and create highway
	while current_point.distance_to(target_point) > num_samples: # TODO: This can still cause an infinite loop I believe, this needs to be a var also.
		highway.add_point(current_point)
		var next_highway_point: Vector2 = ranged_sample_along_line(current_point, target_point)
		current_point = next_highway_point

	# Fill in the remaining distance
	highway.add_point(target_point) # TODO: This can be improved

## Used to determine the next segment of a highway.
## From start_point, sample lines along the range of a cone. Each line will contain `num_samples` of points, 
## which are weighted and summed. Return the final point of the line that follows the highest noise map values.
func ranged_sample_along_line(start_point, target_point) -> Vector2:
	# Initialize return/max values
	var selected_point: Vector2 = Vector2.ZERO
	var highest_weighted_value: float = -float("inf")

	# Calculate the degree range based on the direct angle to target_point
	var angle_to_target = start_point.angle_to_point(target_point)
	var degree_min: float = rad_to_deg(angle_to_target) - degree_range
	var degree_max: float = rad_to_deg(angle_to_target) + degree_range

	# Iterate over the degree_range
	for degree in range(degree_min, degree_max, degree_step): # Poll a range of angles
		var angle: float= deg_to_rad(degree)
		var direction: Vector2 = Vector2(cos(angle), sin(angle)).normalized()
		var direction_total: float = 0

		# Poll along the direction of the current angle
		# i is the distance from the current point (1 pixel at a time)
		for i in range(1, num_samples):
			var pos: Vector2 = start_point + (direction * i)
			var value: float = population_density.base_noise.get_noise_2d(pos[0], pos[1])
			var weight: float = 1 / i # (1 / distance)
			var weighted_value: float = value * weight
			direction_total += weighted_value

		# Update the return point if it has a higher weighted value than current max
		if direction_total > highest_weighted_value:
			highest_weighted_value = direction_total
			selected_point = start_point + (direction * num_samples)

	return selected_point

## Create and return a new Line2D to represent a highway
func create_new_highway_line2d() -> Line2D: 
	var highway: Line2D = Line2D.new()
	highway.width = 10.0
	var highway_color: Color = GlobalData.available_highway_colors.pick_random()
	highway.default_color = highway_color
	GlobalData.available_highway_colors.remove_at(GlobalData.available_highway_colors.find(highway_color))
	add_child(highway)
	return highway

func add_population_center_marker(point: Vector2, normalized_density_value: float) -> void:
	var scale_value: float = (normalized_density_value * .7) + 0.3
	var marker_scale: Vector2 = Vector2(scale_value, scale_value)
	var new_marker: Sprite2D = marker.instantiate()
	new_marker.position = point
	new_marker.scale = marker_scale
	add_child(new_marker)

func debug_value(value, normalized_value, point) -> void:
	print("=======================================")
	print("Value: ", value)
	print("Normalized Value: ", normalized_value)
	print("Point: ", point)
